<application>
  <component name="AppStorage">
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="The x-radius of the rounded corners on the round-rectangle" />
      <item value="Invoked when the specified {@link SurfaceTexture} is about to be destroyed. If returns true, no rendering should happen inside the surface texture after this method is invoked. If returns false, the client needs to call {@link SurfaceTexturerelease()}. Most applications should return true. @param surface The surface about to be destroyed" />
      <item value="Attempts to match the entire region against the pattern." />
      <item value="Return the total number of instructions executed globally (i.e. in all threads)." />
      <item value="drawing cache created in Viewdraw when drawing to a SW canvas." />
      <item value="NOTE: even if previous layer type is HW, we do this to ensure we've cleaned up" />
      <item value="Destroy any previous software drawing cache if present" />
      <item value="For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or {@link android.graphics.Picture} and call {@link draw(Canvas)} on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as {@link android.graphics.Bitmap.ConfigHARDWARE Config.HARDWARE} bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the {@link PixelCopy} API is recommended." />
      <item value="The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, {@link setLayerType(int, Paint)} handles this with hardware rendering." />
      <item value="intended" />
      <item value="animation" />
      <item value="traversal" />
      <item value="traversal Cost Ns" />
      <item value="DEFAULT DROPPED HIGH" />
      <item value="DEFAULT DROPPED FROZEN" />
      <item value="drop Frame Listener Threshold" />
      <item value="ACCUMELAING" />
      <item value="plugin duplicate init" />
      <item value="normal Threshold" />
      <item value="high Threshold" />
      <item value="frozen Threshold" />
      <item value="ZTE" />
      <item value="Modern" />
      <item value="is ZTE Modern Device" />
      <item value="still Receiving Unexpected Stream" />
      <item value="active Participants" />
      <item value="do not compress when the origin image file size less than one value" />
      <item value="focus Alpha" />
      <item value="mRequestPlaybackData: check if there is enough playing buffer pending. playing has higher priority" />
      <item value="we find c recorder cannot fire forceGet and tryGet at needed frequency." />
      <item value="continuous Count" />
      <item value="last Lack Frame" />
      <item value="In some machine (ASUS X008D), player callback implemented badly, will callback twice in one millisecond. So there's no way that the playback after second one can fetch a frame. We should send more frame when we find we are in this situation." />
      <item value="Invoked when the specified {@link SurfaceTexture} is about to be destroyed. If returns true, no rendering should happen inside the surface texture after this method is invoked. If returns false, the client needs to call {@link SurfaceTexturerelease()}. Most applications should return true." />
      <item value="Invoked when the specified {@link SurfaceTexture} is updated through {@link SurfaceTextureupdateTexImage()}. @param surface The surface just updated" />
      <item value="Priority constant for the println method." />
      <item value="Implements a simple runtime profiler. The profiler records start and stop times for several different types of profiles and can then return min, max and average execution times per type. Profile types are independent and may be nested in calling code. This object is a singleton for convenience." />
      <item value="get Elapsed Average Time" />
      <item value="on Rending Lack Performance" />
      <item value="ACCELERATE" />
      <item value="set Blue Tooth Sco State" />
      <item value="increase" />
      <item value="max Permit Bitrate Exceeded" />
      <item value="Flips" />
      <item value="Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded." />
      <item value="doodle cannot send any command now, because all command will be intercepted" />
      <item value="doodle cannot send any command now, because the command has been intercepted" />
      <item value="generic Parameterized Type" />
      <item value="generic Superclass" />
      <item value="Parameterized Type" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="151" />
        <entry key="ENGLISH" value="153" />
        <entry key="POLISH" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1642395939701" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190520000299422" />
      </app-key>
    </option>
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="ESPERANTO" />
      </google-translate>
    </option>
    <option name="translator" value="BAIDU" />
  </component>
</application>